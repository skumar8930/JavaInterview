Lambda expression:
It is the short way to define the body of functional interface abstract method.

example:
package java8.interfaces;
@FunctionalInterface

public interface CalculateSquare {
    Double square(Double x);
}

Now we can implement tha square method in any class direcltly as below.

 public static void implementsCalculateSquare(){
       // CalculateSquare  c1= (x)->{ return x*x ;};
       // CalculateSquare c2 = (x)->  x*x;
        CalculateSquare c3 = x->  x*x;// here x is the value which we will pass in square method
        System.out.println(c3.square(2.0));

    }

    2. example
    ===

    package java8.interfaces;
    @FunctionalInterface
    public interface CompareTwoNumber {
        Integer compareTwoNumber(Integer a, Integer b);

    }
    Uses
    =======
      public static void implementcompareTwoNumber() {
            CompareTwoNumber compareTwoNumber =( a, b)->{
            if (a > b) {
                return a;
            } else
                return b;
        };//semicolon required because lambda expression is inline expression

            System.out.println(compareTwoNumber.compareTwoNumber(2,5));
        }

Functional interface :
==========================================
Functional interface is a intefce which have only one abstrat method and it may have multiple static and default method.
@FunctionalInterface annotation is optional for for functional interface. if there is more than one abstract method in interface
then it is not functional interface.
Functional interface is the target of labda expression, lambda expression is used to define the abstract method body.
The argument of  different method of stream Api having any functionl interface type, so that we can use
lambda expression for that.
lambda expression return type is functionla interface type.

Some functional interfaces define in java 8
1. Predicate
2.Function
3.Consumer
4.Supplier
5.Comprator



1. Predicate
======================
Predicate is a single argument function which return true or false based on the condition.
methods.
boolean test(T t) is the one abstract method.
there is 3 default method
default Predicate or(Preficate  p) --Logical OR
default Predicate and(Preficate  p) --Logical AND
default Predicate negate(Preficate  p) --Logical NOT it reverse the Predicate
one static method
static isEqual(Object targetRef)

example of Predicate

1. Predicate<Employee> p1= e-> e.getSalary()>20000;
2. Predicate<Employee> p2= e-> e.getSalary()<30000;
3. Predicate<Employee> p3= p1.and(p2);// return true if p1 and p2 are true

https://www.geeksforgeeks.org/java-8-predicate-with-examples/

https://www.programiz.com/java-programming/lambda-expression

 ===================================================================

 2.Function interface

 It reprsent a function which takes in one argument and produces a result, it does not return boolean value like Predicate.
 Methods:-
 ---------
 R apply(T t) abstract method

 other methods
 .............
Function andThen(Function f)
Function compose(Functiojn f)
Function identity():-  identity is a static method of Function interface that returns a Function that always returns its input argument.

1. What is Function?
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}


It represents a function that takes one input (T) and returns one output (R).
Think of it like:
T (input)  ---> Function --->  R (output)
2. Key Points
T = type of input
R = type of output
Method:
R apply(T t) → executes the function
3. Example Usage
Simple Function
Function<Integer, String> intToString = i -> "Number: " + i;
System.out.println(intToString.apply(10));  // Output: Number: 10
Here:
Input (T) = Integer
Output (R) = String
Function in Streams
List<String> names = List.of("Alice", "Bob", "Charlie");
List<Integer> lengths = names.stream()
    .map(String::length)  // Function<String, Integer>
    .toList();
System.out.println(lengths);  // [5, 3, 7]
map() takes a Function<T, R>
Here Function<String, Integer> is used
4. Common Methods in Function

Besides apply(), there are useful default methods:

andThen() → chain another function after current one

Function<Integer, Integer> square = x -> x * x;
Function<Integer, String> toString = x -> "Value: " + x;

Function<Integer, String> pipeline = square.andThen(toString);

System.out.println(pipeline.apply(5)); // Value: 25


compose() → chain another function before current one

Function<Integer, Integer> doubleIt = x -> x * 2;
Function<Integer, Integer> squareIt = x -> x * x;

Function<Integer, Integer> pipeline = squareIt.compose(doubleIt);

System.out.println(pipeline.apply(3)); // (3*2)=6 → 6*6=36


identity() → returns the same input

Function<String, String> identityFn = Function.identity();

System.out.println(identityFn.apply("Hello")); // Hello

5. Why important in groupingBy?
Collectors.groupingBy(Function<? super T, ? extends K> classifier)
Here:
classifier is a Function<T, K>
It takes a stream element (T) and returns the grouping key (K)
Example:
Map<String, List<String>> byLength =
    names.stream()
         .collect(Collectors.groupingBy(String::length + "")); // Oops, not valid
Correct:
Map<Integer, List<String>> byLength =
    names.stream()
         .collect(Collectors.groupingBy(String::length))
classifier = String::length
Type: Function<String, Integer>
Groups words by their length

✅ In short:

Function<T, R> is a functional interface that maps T → R.
Heavily used in streams (map, groupingBy, collect, etc.).

Function use cases:-

1. map(Function<T,R>)
Transforms each element into another type.

List<String> names = List.of("Alice", "Bob", "Charlie");
List<Integer> lengths = names.stream()
    .map(String::length)   // Function<String, Integer>
    .toList();
System.out.println(lengths); // [5, 3, 7]
Here Function<String,Integer> is applied to each element.
Input T = String, Output R = Integer.

2. flatMap(Function<T, Stream<R>>)
Maps each element to a stream, then flattens.

List<String> words = List.of("java", "stream");
List<String> chars = words.stream()
    .flatMap(word -> word.chars().mapToObj(c -> String.valueOf((char)c)))
    .toList();
System.out.println(chars); // [j, a, v, a, s, t, r, e, a, m]
Function<String, Stream<String>>
Converts each word into a stream of characters.

3. collect(Collectors.groupingBy(Function))

Groups elements by a classifier function.
List<String> names = List.of("Tom", "Sam", "Harry", "Tim");

Map<Integer, List<String>> groupedByLength =
    names.stream()
         .collect(Collectors.groupingBy(String::length)); // Function<String, Integer>
System.out.println(groupedByLength);
// {3=[Tom, Sam], 5=[Harry], 3=[Tim]} (merged automatically)
Function<String,Integer> tells how to group.

4. toMap(Function<T,K>, Function<T,V>)
Creates a map by applying two functions: one for the key, one for the value.

List<String> names = List.of("Alice", "Bob");
Map<String, Integer> nameLengthMap =
    names.stream()
         .collect(Collectors.toMap(
             Function.identity(),  // Function<String,String> (key = name itself)
             String::length        // Function<String,Integer> (value = length)
         ));
System.out.println(nameLengthMap); // {Alice=5, Bob=3}

5. mapToInt, mapToLong, mapToDouble
Use a Function-like mapper specialized for primitives.
int sum = names.stream()
    .mapToInt(String::length)  // Function<String, Integer> (primitive specialization)
    .sum();
System.out.println(sum); // 15

6. peek(Function-like Consumer)

Not exactly Function (uses Consumer instead), but worth noting — peek() often works alongside Function in pipelines.
names.stream()
    .map(String::toUpperCase)     // Function<String, String>
    .peek(System.out::println)    // Consumer<String>
    .count();

✅ Summary — Function is used in streams when you:
transform elements (map)
flatten elements (flatMap)
classify/group (groupingBy)
build maps (toMap)
map to primitives (mapToInt, etc.)

// some Question for practice
 //https://blog.devgenius.io/java-8-coding-and-programming-interview-questions-and-answers-62512c44f062

There is two type of operation in java-8
1. Intermediate operation
2. Terminal operation

Intermediate operation results is again stream  of list.
example,

filter()
map()
flatmap()
distinct()
sorted()
peek()
limit()
skip()

In Terminal operation we are not getting stream of list , it give us a single result.


